define(["require", "exports", 'main'], function (require, exports, main) {
  exports.test = function(){



    QUnit.module('main', function() {

      QUnit.test('Object.keys', function(assert) {
        assert.deepEqual(Object.keys(main).sort(), [
          "IdPool",
          "_init", // TODO: private?
          "argFilter",
          "argList",
          "argSort",
          "bind",
          "bounds",
          "callable",
          "constant",
          "constantFalse",
          "constantTrue",
          "copyDnD",
          "delayedCall",
          "extendClass",
          "fix_id", // TODO: camel case?
          "flagId",
          "getter",
          "hasDnDType",
          "hash",
          "identity",
          "indexOf",
          "isFunction",
          "isUndefined",
          "mixin",
          "mod",
          "noop",
          "offline",
          "offset",
          "onDOMNodeRemoved",
          "param",
          "random_id", // TODO: camel case?
          "resolveIn",
          "search",
          "server_json_suffix", // TODO: camel case?
          "server_url", // TODO: camel case?
          "uniqueId",
          "uniqueString",
          "updateDropEffect",
          "version"
        ]);
      });

      QUnit.module('IdPool', function() { // TODO: Should this be public?
        QUnit.test('Object.keys', function(assert) {
          assert.deepEqual(Object.keys(new main.IdPool()), ['counter', 'free']);
        });
      });

      /* TODO: Add at least one test for main._init
      QUnit.module('_init', function() {
        QUnit.test('???', function(assert) {
          assert.equal(main._init(), '???');
        });
      })
      */


      QUnit.module('bounds', function() {
        /* TODO: This seems odd. For instance, there is already
           an x and y provided by the DOM, but we give a different
           meaning to these.  */
        // TODO: Test sometimes breaks if console is open.
        // QUnit.test('body', function(assert) {
        //   var bounds = main.bounds(document.getElementsByTagName('body')[0]);
        //   assert.ok(bounds.x > 0);
        //   assert.ok(bounds.y > 0);
        //   assert.ok(bounds.w > 0);
        //   assert.ok(bounds.h > 0);
        // });
        QUnit.test('false', function(assert) {
          var bounds = main.bounds(false);
          assert.ok(bounds.x == 0);
          assert.ok(bounds.y == 0);
          assert.ok(bounds.w == 0);
          assert.ok(bounds.h == 0);
        });
        QUnit.test('not DOM', function(assert) {
          var bounds = main.bounds(false);
          assert.ok(bounds.x == 0);
          assert.ok(bounds.y == 0);
          assert.ok(bounds.w == 0);
          assert.ok(bounds.h == 0);
        });
      });



      /* TODO: Add at least one test for main.copyDnD
      QUnit.module('copyDnD', function() {
        QUnit.test('???', function(assert) {
          assert.equal(main.copyDnD(), '???');
        });
      })
      */

      /* TODO: Add at least one test for main.delayedCall
      QUnit.module('delayedCall', function() {
        QUnit.test('???', function(assert) {
          assert.equal(main.delayedCall(), '???');
        });
      })
      */

      /* TODO: Add at least one test for main.extendClass
      QUnit.module('extendClass', function() {
        QUnit.test('???', function(assert) {
          assert.equal(main.extendClass(), '???');
        });
      })
      */

      /* TODO: Add at least one test for main.fix_id
      QUnit.module('fix_id', function() {
        QUnit.test('???', function(assert) {
          assert.equal(main.fix_id(), '???');
        });
      })
      */

      // TODO: How is this used? And what's the desired behavior?
      QUnit.module('flagId', function() {
        QUnit.test('NaN', function(assert) {
          assert.equal(main.flagId(), null);
        });
        QUnit.test('domain', function(assert) {
          assert.equal(main.flagId('fake-domain'), null);
        });
        QUnit.test('domain + ID', function(assert) {
          assert.equal(main.flagId('fake-domain', 42), 42);
        });
      });

      QUnit.module('getter', function() {
        QUnit.test('one arg', function(assert) {
          getter = main.getter('a');
          assert.equal(getter({a: 42}), 42);
        });
        QUnit.test('two args', function(assert) {
          getter = main.getter('a', 'z');
          assert.deepEqual(getter({a: 42, z: 24}), [42, 24]);
        });
      });

      /* TODO: Add at least one test for main.hasDnDType
      QUnit.module('hasDnDType', function() {
        QUnit.test('???', function(assert) {
          assert.equal(main.hasDnDType(), '???');
        });
      })
      */

      /* TODO: Add at least one test for main.hash
      QUnit.module('hash', function() {
        QUnit.test('???', function(assert) {
          assert.equal(main.hash(), '???');
        });
      })
      */

      QUnit.module('identity', function() {
        function assert_identity(x) {
          QUnit.test(x, function(assert) {
            assert.deepEqual(main.identity(x), x);
          });
        }
        assert_identity(false);
        assert_identity(true);
        assert_identity(function(x){});
        assert_identity('string');
      });

      QUnit.module('indexOf', function() {
        QUnit.test('not in there', function(assert) {
          assert.equal(main.indexOf([1], function(x) {return x > 10}), -1);
        });
        QUnit.test('one match', function(assert) {
          assert.equal(main.indexOf([1,100], function(x) {return x > 10}), 1);
        });
        QUnit.test('two matches', function(assert) {
          assert.equal(main.indexOf([20,100], function(x) {return x > 10}), 0);
        });
      });

      QUnit.module('isFunction', function() {
        QUnit.test('built-in', function(assert) {
          assert.ok(main.isFunction(Math.sin));
        });
        QUnit.test('in-line', function(assert) {
          assert.ok(main.isFunction(function() {}));
        });
        QUnit.test('not a function', function(assert) {
          assert.notOk(main.isFunction('not a function'));
        });
      });

      /* TODO: Add at least one test for main.isUndefined
      QUnit.module('isUndefined', function() {
        QUnit.test('???', function(assert) {
          assert.equal(main.isUndefined(), '???');
        });
      })
      */

      /* TODO: Add at least one test for main.mixin
      QUnit.module('mixin', function() {
        QUnit.test('???', function(assert) {
          assert.equal(main.mixin(), '???');
        });
      })
      */



      QUnit.module('noop', function() {
        QUnit.test('noop', function(assert) {
          assert.equal(main.noop(), null);
        });
      });

      QUnit.module('offline', function() {
        QUnit.test('offline', function(assert) {
          assert.equal(main.offline, false);
        });
      });

      // TODO: Fragile?
      // QUnit.module('offset', function() {
      //   QUnit.test('header', function(assert) {
      //     // fragile?
      //     assert.deepEqual(main.offset(document.getElementById('qunit-header')), {
      //       height: 48,
      //       left: 8,
      //       top: 8,
      //       width: window.innerWidth - 16
      //     });
      //   });
      // });

      QUnit.module('onDOMNodeRemoved', function() {
        QUnit.test('one node', function(assert) {
          // TODO: with assert.async, the test just stalls?
          //var done = assert.async();
          document.getElementById('qunit-fixture').innerHTML = '<div id="stub"></div>';
          var stub = document.getElementById('stub');
          main.onDOMNodeRemoved(stub, function() {
            assert.ok(true);
            //done();
          });
          stub.remove();
          assert.expect(0);
        });
        // TODO: two node list.
      });

      // TODO: Expose PropertyHandler for the sake of testing?
      // Running just against this url is fragile, and does not provide good coverage.
      QUnit.module('param', function() {
        QUnit.test('properties', function (assert) {
          assert.deepEqual(properties(main.param), [
            "forEach",
            "getInt",
            "getProp",
            "is",
            "keys",
            "map",
            "parse",
            "removeProp",
            "toString"
          ]);
        });
        QUnit.test('keys', function (assert) {
          assert.deepEqual(main.param.keys(), ['test']);
        });
      });




    });

  }
});
